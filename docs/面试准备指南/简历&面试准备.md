# AI 旅行规划师 - 简历材料 & 面试准备指南

本文档帮助你将此项目写入简历，并为面试做充分准备。

## 目录

- [简历描述模板](#简历描述模板)
- [核心技术亮点](#核心技术亮点)
- [面试高频问题](#面试高频问题)
- [项目数据统计](#项目数据统计)
- [加分表述建议](#加分表述建议)

---

## 简历描述模板

### 版本1：详细版（适合技术岗位）

```
AI 旅行规划师 | 全栈 Web 应用 | 独立开发
Next.js 15 + TypeScript + Supabase + LangGraph

• 设计并实现基于 LangGraph 的多智能体协作系统，8 个专家 Agent 通过状态图编排协作完成智能行程规划，
  支持预算超支自动重试、并行执行和检查点恢复
• 构建 LLM-as-Judge 自动化评估系统，从逻辑性、完整性、可行性、预算符合度、格式正确性 5 个维度
  评估 AI 生成质量，覆盖 20 个测试场景，通过率阈值 3.5/5.0
• 集成高德地图 API，实现 MCP 协议工具调用，封装天气、POI 搜索、路线规划等 9 个 MCP 工具
• 实现 Offline-First 架构，基于 IndexedDB 的离线缓存和 Last-Write-Wins 冲突解决的数据同步引擎
• 建立完整的可观测性体系：Prometheus 指标、多后端追踪（Console/JSON/LangSmith）、工作流可视化调试
• 297 个 TypeScript 文件，44 个单元/集成测试文件，覆盖率 80%+
```

### 版本2：简洁版（适合综合简历）

```
AI 旅行规划师 | Next.js 15 全栈应用
• 基于 LangGraph 实现 8 Agent 多智能体系统，支持状态图编排、预算重试和并行执行
• Offline-First PWA 架构，IndexedDB 离线存储 + 自动同步引擎
• 集成高德地图 MCP 协议、Supabase 认证、Prometheus 监控
• 297 个 TypeScript 文件，44 个测试文件，覆盖率 80%+
```

### 版本3：一句话描述

```
基于 LangGraph 多智能体架构的 AI 旅行规划全栈应用，支持 PWA 离线访问和 Prometheus 可观测性监控
```

---

## 核心技术亮点

### 1. LangGraph 多智能体架构 ⭐⭐⭐

> **面试重点**：这是项目最大的技术亮点，务必熟练掌握

#### 架构图

```
用户输入
    │
    ▼
┌───────────────────┐
│  Weather Scout    │  获取天气 + 生成策略标签
└───────────────────┘
    │
    ▼
┌───────────────────┐
│ Itinerary Planner │  生成行程骨架
└───────────────────┘
    │
    ▼
┌───────────────────┐
│Attraction Enricher│  增强景点详情（门票、开放时间等）
└───────────────────┘
    │
    ├──────────────────┬──────────────────┐
    ▼                  ▼                  ▼
┌──────────┐    ┌──────────┐    ┌──────────┐
│  Hotel   │    │Transport │    │  Dining  │    并行执行
│  Agent   │    │  Agent   │    │  Agent   │
└──────────┘    └──────────┘    └──────────┘
    │                  │                  │
    └──────────────────┴──────────────────┘
                       │
                       ▼
              ┌───────────────────┐
              │  Budget Critic    │  预算审计
              └───────────────────┘
                       │
              ┌───────┴───────┐
              │ 超预算?       │
              │ Yes → 重试    │  ← 条件边 + 循环
              │ No  → 完成    │
              └───────────────┘
                       │
                       ▼
              ┌───────────────────┐
              │  Finalize Agent   │  生成最终行程
              └───────────────────┘
```

#### 关键代码位置

| 模块 | 文件路径 | 说明 |
|------|----------|------|
| 状态定义 | `lib/agents/state.ts` | TripState Annotation 定义 |
| 工作流定义 | `lib/agents/workflow.ts` | StateGraph 节点和边定义 |
| Agent 节点 | `lib/agents/nodes/*.ts` | 8 个专家 Agent 实现 |
| Agent 提示词 | `lib/agents/prompts/*.ts` | System Prompts |
| MCP 客户端 | `lib/agents/mcp-client.ts` | 高德地图工具封装 |
| 检查点 | `lib/agents/checkpointer.ts` | MemorySaver/PostgresSaver |
| 追踪器 | `lib/agents/tracer.ts` | Console/JSON/LangSmith |
| 指标收集 | `lib/agents/metrics.ts` | Prometheus 格式指标 |

#### 核心实现代码示例

**状态定义（`lib/agents/state.ts`）**：
```typescript
const TripStateAnnotation = Annotation.Root({
  // 用户输入
  userInput: Annotation<TripFormData>,

  // 天气上下文
  weather: Annotation<WeatherOutput | null>({
    default: () => null,
    reducer: (_, new_val) => new_val,  // 后值覆盖
  }),

  // 行程草稿
  draftItinerary: Annotation<DraftItinerary | null>({
    default: () => null,
  }),

  // 资源数据（并行 Agent 结果）
  accommodation: Annotation<AccommodationResult | null>(),
  transport: Annotation<TransportResult | null>(),
  dining: Annotation<DiningResult | null>(),

  // 预算审计
  budgetResult: Annotation<BudgetResult | null>(),
  retryCount: Annotation<number>({
    default: () => 0,
    reducer: (current, delta) => current + delta,  // 累加
  }),

  // 最终输出
  finalItinerary: Annotation<Itinerary | null>(),
})
```

**工作流构建（`lib/agents/workflow.ts`）**：
```typescript
const workflow = new StateGraph(TripStateAnnotation)

// 添加节点
workflow
  .addNode("weather_scout", weatherScoutAgent)
  .addNode("itinerary_planner", itineraryPlannerAgent)
  .addNode("accommodation", accommodationAgent)
  .addNode("transport", transportAgent)
  .addNode("dining", diningAgent)
  .addNode("budget_critic", budgetCriticAgent)
  .addNode("finalize", finalizeAgent)

// 定义边（执行顺序）
workflow
  .addEdge(START, "weather_scout")
  .addEdge("weather_scout", "itinerary_planner")
  // 并行扇出
  .addEdge("itinerary_planner", "accommodation")
  .addEdge("itinerary_planner", "transport")
  .addEdge("itinerary_planner", "dining")
  // 扇入汇合
  .addEdge("accommodation", "budget_critic")
  .addEdge("transport", "budget_critic")
  .addEdge("dining", "budget_critic")

// 条件边：预算审计决策
workflow.addConditionalEdges(
  "budget_critic",
  (state: TripState) => {
    if (state.budgetResult?.isWithinBudget) return "finalize"
    if (state.retryCount >= 3) return "finalize"  // 最大重试
    return "retry"
  },
  {
    finalize: "finalize",
    retry: "itinerary_planner",  // 循环回规划节点
  }
)

workflow.addEdge("finalize", END)
```

#### 为什么选择 LangGraph？

| 需求 | 手动实现 | LangGraph |
|------|---------|-----------|
| 多 Agent 协作 | 自己写调度逻辑 | StateGraph 节点编排 |
| 预算超支重试 | while 循环 + 状态管理 | 条件边 + 循环边 |
| 并行执行 | Promise.all | 并行节点 (Fan-out/Fan-in) |
| 状态传递 | 手动管理对象 | 内置 State Channel |
| 执行追踪 | 自己实现日志 | 内置 Tracing |
| 中断恢复 | 复杂 | 内置 Checkpointer |

---

### 2. MCP 协议集成

#### 什么是 MCP？

Model Context Protocol (MCP) 是 Anthropic 提出的标准化工具调用协议，让 AI Agent 可以统一方式访问外部 API。

#### 实现内容

**独立 MCP Server**（`mcp-servers/amap/`）：
- 9 个 MCP 工具
- 支持 SSE（开发）和 stdio（生产）两种连接模式
- 24 个单元测试

**工具列表**：

| 工具名称 | 功能 | 使用场景 |
|----------|------|----------|
| `get_weather_forecast` | 天气预报 | Weather Scout |
| `search_poi` | POI 关键词搜索 | Itinerary Planner、Dining |
| `search_nearby` | 周边搜索 | Accommodation |
| `get_driving_route` | 驾车路线 | Transport |
| `get_walking_route` | 步行路线 | Transport |
| `get_transit_route` | 公交路线 | Transport |
| `geocode` | 地理编码 | Itinerary Planner |
| `reverse_geocode` | 逆地理编码 | 坐标修正 |
| `calculate_distance` | 距离计算 | Transport |

#### MCP 客户端封装（`lib/agents/mcp-client.ts`）

```typescript
class MCPClient {
  async getWeatherForecast(city: string): Promise<WeatherData>
  async searchPOI(params: POISearchParams): Promise<POI[]>
  async searchNearby(params: NearbySearchParams): Promise<POI[]>
  async getDrivingRoute(origin: Location, dest: Location): Promise<Route>
  async getWalkingRoute(origin: Location, dest: Location): Promise<Route>
  async getTransitRoute(origin: Location, dest: Location, city: string): Promise<Route>
  async geocode(address: string, city?: string): Promise<Location>
  async reverseGeocode(location: Location): Promise<Address>
  async calculateDistance(origins: Location[], destinations: Location[]): Promise<Distance[]>
}
```

---

### 3. Offline-First PWA 架构

#### 架构图

```
┌─────────────┐
│   用户界面   │
└──────┬──────┘
       │
┌──────┴──────────────────────────────┐
│  React Hooks Layer                   │
│  - useOfflineTrips                   │
│  - useOfflineTrip                    │
│  - useSync                           │
└──────┬──────────────────────────────┘
       │
┌──────┴──────────────────────────────┐
│  Data Management Layer               │
│  - lib/offline.ts (IndexedDB)        │
│  - lib/sync.ts (Sync Engine)         │
└──────┬──────────────────────────────┘
       │
┌──────┴──────────────────────────────┐
│  Storage Layer                       │
│  ┌────────────┐  ┌────────────┐     │
│  │ IndexedDB  │  │  Supabase  │     │
│  │  (Local)   │  │  (Remote)  │     │
│  └────────────┘  └────────────┘     │
└──────────────────────────────────────┘
       │
┌──────┴──────────────────────────────┐
│  Service Worker                      │
│  - Static asset caching              │
│  - API response caching              │
│  - Offline fallback                  │
└──────────────────────────────────────┘
```

#### IndexedDB Schema

```typescript
interface OfflineDB extends DBSchema {
  trips: {
    key: string              // Trip ID
    value: Trip
    indexes: {
      'by-user': string      // Index by user_id
      'by-updated': string   // Index by updated_at
    }
  }
  expenses: {
    key: string
    value: Expense
    indexes: {
      'by-trip': string      // Index by trip_id
    }
  }
  sync_queue: {
    key: number              // Auto-increment ID
    value: SyncQueueItem
    indexes: {
      'by-status': string    // Index by status
    }
  }
}
```

#### 同步队列设计

```typescript
interface SyncQueueItem {
  id?: number
  type: 'create' | 'update' | 'delete'
  entity: 'trip' | 'expense'
  entityId: string
  data?: any
  timestamp: number
  status: 'pending' | 'syncing' | 'synced' | 'failed'
  error?: string
}
```

#### 冲突解决策略

**Last-Write-Wins（最后修改优先）**：
```typescript
function resolveConflict<T extends { updated_at: string }>(
  local: T,
  remote: T
): T {
  const localTime = new Date(local.updated_at).getTime()
  const remoteTime = new Date(remote.updated_at).getTime()
  return localTime > remoteTime ? local : remote
}
```

#### Service Worker 缓存策略

```javascript
// 静态资源：Cache First（长期有效）
{
  urlPattern: /\.(?:png|jpg|jpeg|svg|gif|webp)$/i,
  handler: 'CacheFirst',
  options: {
    cacheName: 'images',
    expiration: { maxEntries: 64, maxAgeSeconds: 30 * 24 * 60 * 60 }
  }
}

// API：Network First（保证数据新鲜）
{
  urlPattern: /\/api\/.*$/i,
  handler: 'NetworkFirst',
  options: {
    cacheName: 'api',
    networkTimeoutSeconds: 10
  }
}
```

---

### 4. 数据库设计（Supabase + RLS）

#### 表结构

| 表名 | 说明 | 关键字段 |
|------|------|----------|
| `profiles` | 用户配置 | theme, default_model, default_budget |
| `trips` | 行程数据 | itinerary (JSONB), share_token, is_public |
| `expenses` | 费用追踪 | category, amount, trip_id |
| `api_keys` | 加密 API Key | encrypted_key, key_prefix, is_active |

#### RLS 策略示例

```sql
-- 用户只能访问自己的行程
CREATE POLICY "Users can view own trips" ON trips
  FOR SELECT USING (auth.uid() = user_id);

-- 公开行程任何人可访问
CREATE POLICY "Anyone can view public trips" ON trips
  FOR SELECT USING (is_public = true);
```

#### 为什么用 JSONB 存储行程？

1. **结构复杂**：天 → 活动 → 详情，嵌套层级深
2. **整体读写**：通常一次读取/更新整个行程
3. **灵活性**：不同行程结构可能不同
4. **索引支持**：PostgreSQL JSONB 支持 GIN 索引

---

### 5. 组件架构优化（Phase 3 重构）

#### 重构成果

| 组件 | 优化前 | 优化后 | 减少 |
|------|--------|--------|------|
| TripOverviewMap | 594 行 | 323 行 | -45.6% |
| ApiKeyManager | 561 行 | 351 行 | -37.4% |
| MapView | 484 行 | 401 行 | -17.1% |

#### 提取的可复用组件

| 组件 | 位置 | 说明 |
|------|------|------|
| PhotoCarousel | `components/shared/` | 照片轮播 |
| RatingDisplay | `components/shared/` | 星级评分 |
| MapLegend | `components/map/` | 地图图例 |
| TripMapToolbar | `components/map/` | 地图工具栏 |

#### 工具模块

| 模块 | 位置 | 说明 |
|------|------|------|
| ui-helpers | `lib/ui-helpers.ts` | 颜色、emoji、样式常量 |
| map-markers | `lib/map-markers.ts` | 地图标记创建工具 |

---

### 6. 可观测性体系

#### 追踪器（`lib/agents/tracer.ts`）

支持三种后端：
- **Console**：开发调试，输出到控制台
- **JSON**：本地分析，输出到文件
- **LangSmith**：生产监控，集成 LangSmith 平台

#### 指标收集（`lib/agents/metrics.ts`）

Prometheus 格式指标端点 `/api/metrics`：

```
# 工作流指标
langgraph_workflow_executions_total
langgraph_workflow_duration_milliseconds
langgraph_workflow_retries_total

# Agent 指标
langgraph_agent_executions_total
langgraph_agent_duration_milliseconds

# MCP 工具指标
langgraph_mcp_tool_calls_total
langgraph_mcp_tool_duration_milliseconds
langgraph_mcp_cache_hits_total
```

#### 调试页面

开发环境访问 `/dashboard/debug`：
- 工作流状态图可视化
- 追踪记录列表
- 执行时间线
- 状态数据查看器

---

## 面试高频问题

### 架构设计类

#### Q1: 描述一下项目的整体架构

```
分层架构：
1. 展示层：Next.js 15 App Router + React 组件
2. API 层：Next.js Route Handlers + 中间件（认证、错误处理）
3. 业务层：Service 层 + LangGraph Agent 编排
4. 数据层：Supabase (PostgreSQL + RLS) + IndexedDB (离线)
5. 外部集成：DeepSeek/ModelScope AI + 高德地图 MCP
```

#### Q2: 为什么选择 Next.js？

- **全栈一体**：降低运维复杂度
- **App Router**：支持 Server Components，减少客户端 JS
- **API Routes**：满足后端需求，无需独立部署
- **部署简单**：Vercel 一键部署

#### Q3: 如何处理 AI 生成的不确定性？

1. **JSON Schema 约束**：在 prompt 中明确输出格式
2. **多层校验**：
   - JSON 解析容错（支持 markdown 代码块包裹）
   - 坐标修正（高德 API 获取准确 GCJ-02 坐标）
   - 地理聚类优化（相近景点安排同一天）
3. **重试机制**：Budget Critic 超预算自动触发重新规划（最多 3 次）

---

### 技术实现类

#### Q4: LangGraph 状态如何在多个 Agent 间共享？

```typescript
// 使用 Annotation.Root 定义类型安全的状态 Schema
const TripStateAnnotation = Annotation.Root({
  weather: Annotation<WeatherOutput | null>({
    default: () => null,
    reducer: (_, new_val) => new_val,  // 新值覆盖旧值
  }),
  retryCount: Annotation<number>({
    default: () => 0,
    reducer: (current, delta) => current + delta,  // 累加
  }),
})

// Agent 只返回要更新的字段，LangGraph 自动合并
async function weatherScoutAgent(state: TripState): Promise<Partial<TripState>> {
  const weather = await fetchWeather(state.userInput.destination)
  return { weather }  // 只返回 weather 字段
}
```

#### Q5: 离线同步如何处理冲突？

采用 **Last-Write-Wins** 策略：
1. 比较 `updated_at` 时间戳
2. 保留较新的版本
3. 更新另一端的数据

**选择理由**：
- 实现简单可靠
- 旅行行程修改频率不高
- 用户通常单设备使用

#### Q6: 如何保证 API Key 的安全？

1. **加密存储**：AES-256-CBC 加密，密钥存服务端环境变量
2. **最小暴露**：前端只显示 `key_prefix`（如 `sk-...****`）
3. **服务端解密**：解密操作只在服务端执行
4. **测试不暴露**：支持测试有效性但不返回完整 key

---

### 性能优化类

#### Q7: 地图组件如何优化？

1. **统一加载**：`useAMapLoader` Hook 避免重复加载
2. **标记聚合**：减少 DOM 元素数量
3. **工具函数提取**：`map-markers.ts` 减少组件重渲染
4. **懒加载**：地图组件按需加载

#### Q8: PWA 缓存策略如何设计？

| 资源类型 | 策略 | 原因 |
|---------|------|------|
| 图片/字体 | Cache First | 不常变化，优先本地 |
| JS/CSS | Cache First | 版本化，优先本地 |
| API | Network First | 数据实时性重要 |
| 健康检查 | Network Only | 必须实时 |

---

### 项目经验类

#### Q9: 开发过程中遇到的最大挑战？

> **LangGraph 多智能体系统的预算重试循环**
>
> 最初直接用 while 循环实现，但状态管理混乱，难以追踪执行过程。
>
> 改用 LangGraph 的条件边后：
> 1. 代码更清晰，状态流转一目了然
> 2. 自动获得检查点恢复能力
> 3. 可以通过追踪器观察每次重试的状态变化
> 4. 并行执行的 Agent 自动等待合并

#### Q10: 如何保证代码质量？

1. **Phase 3 组件重构**：建立复用体系，消除 754 行重复代码
2. **测试覆盖**：80% 覆盖率阈值，44 个测试文件
3. **类型安全**：TypeScript 严格模式
4. **代码规范**：ESLint + 规范化提交信息
5. **文档完善**：40+ 文档文件

#### Q11: 为什么用 JSONB 而不是关系型设计存储行程？

1. **结构复杂**：天 → 活动 → 详情，嵌套层级深
2. **整体操作**：通常整体读写，不需要单独查询子元素
3. **灵活性高**：不同行程可能有不同的结构
4. **PostgreSQL 支持**：JSONB 支持索引和复杂查询

---

## 项目数据统计

| 指标 | 数值 |
|------|------|
| TypeScript 文件数 | 297 |
| 测试文件数 | 44 |
| 文档文件数 | 40+ |
| Agent 数量 | 8 |
| MCP 工具数 | 9 |
| 组件重构减少代码 | 754 行 |
| 测试覆盖率阈值 | 80% |
| 数据库表数 | 4 |
| React Hooks 数 | 12 |

---

## 加分表述建议

面试时可以使用这些表述来展示技术深度：

1. **"从单体到多智能体的架构演进"**
   - 体现架构思考能力
   - 说明为什么需要演进，演进带来的好处

2. **"基于 MCP 协议的工具标准化"**
   - 体现对前沿技术的跟进
   - 说明 MCP 协议的优势

3. **"Offline-First 设计理念"**
   - 体现用户体验意识
   - 说明离线场景的重要性

4. **"可观测性三件套：追踪、指标、日志"**
   - 体现生产级思维
   - 说明在调试和监控中的作用

5. **"Phase 3 组件重构"**
   - 体现重构能力和代码洁癖
   - 说明重构的目标和成果

---

## 延伸阅读

- [多智能体架构升级计划](../架构设计/多智能体架构升级计划.md) - LangGraph 详细设计文档
- [Phase3组件重构报告](../架构设计/Phase3组件重构报告.md) - 组件优化详细报告
- [PWA技术实现](../技术文档/PWA技术实现.md) - 离线功能技术文档
- [数据库设置](../技术文档/数据库设置.md) - Supabase 配置指南
- [测试指南](../测试文档/测试指南.md) - 测试体系说明

---

**最后更新**: 2025-12-01
